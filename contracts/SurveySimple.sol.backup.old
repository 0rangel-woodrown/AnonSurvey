// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {SepoliaZamaGatewayConfig} from "fhevm/config/ZamaGatewayConfig.sol";
import {Gateway} from "fhevm/gateway/lib/Gateway.sol";
import {
    FHE,
    ebool,
    euint8,
    euint16,
    euint32,
    euint64,
    euint128,
    inEuint8,
    inEuint16,
    inEuint32,
    inEuint64,
    inEuint128
} from "@fhevm/solidity/lib/FHE.sol";

/// @title AnonSurvey - Advanced FHE-Powered Anonymous Survey Platform
/// @notice Implements comprehensive survey management with multi-question support, analytics, and incentive mechanisms
/// @dev Features 10-state lifecycle, 5 roles, complex statistical analysis, and Gateway async decryption
contract SurveySimple is SepoliaZamaGatewayConfig {
    // ============ Enums ============

    enum SurveyState {
        Draft,              // Survey created but not published
        Published,          // Survey published
        Active,             // Survey accepting responses
        Paused,             // Temporarily paused
        Closing,            // Final collection period
        Analyzing,          // Data analysis in progress
        Completed,          // Survey completed
        Archived,           // Archived for reference
        Cancelled,          // Survey cancelled
        Finalized           // Results finalized
    }

    enum QuestionType {
        SingleChoice,       // Single choice (1-5)
        MultipleChoice,     // Multiple options
        Rating,             // Rating scale (1-10)
        YesNo,              // Binary yes/no
        Ranking,            // Rank options
        Numeric,            // Numeric input
        Sentiment           // Sentiment (-5 to +5)
    }

    enum SurveyCategory {
        Market,             // Market research
        Product,            // Product feedback
        Service,            // Service quality
        Employee,           // Employee satisfaction
        Customer,           // Customer experience
        Academic,           // Academic research
        Opinion             // Public opinion
    }

    enum ParticipantTier {
        Basic,              // Basic participant
        Regular,            // Regular participant
        Active,             // Active contributor
        Verified,           // Verified participant
        Expert,             // Expert participant
        Premium             // Premium tier
    }

    enum IncentiveType {
        None,               // No incentive
        Fixed,              // Fixed reward
        Tiered,             // Tiered based on quality
        Lottery,            // Random lottery
        TokenBased,         // Token rewards
        NFTBased            // NFT rewards
    }

    // ============ Structs ============

    struct Survey {
        uint256 surveyId;
        address creator;
        SurveyState state;
        SurveyCategory category;
        IncentiveType incentiveType;

        string title;
        string description;
        uint256 createdAt;
        uint256 publishedAt;
        uint256 startTime;
        uint256 endTime;
        uint256 deadline;

        // Encrypted survey metrics
        euint32 totalResponsesCipher;       // Total responses count
        euint32 validResponsesCipher;       // Valid responses
        euint32 qualityScoreCipher;         // Overall quality score (0-10000)
        euint32 completionRateCipher;       // Completion rate (0-10000)
        euint16 participationRateCipher;    // Participation % (0-10000)
        euint16 avgResponseTimeCipher;      // Average response time (seconds)
        euint8 satisfactionScoreCipher;     // Satisfaction score (0-100)
        euint8 reliabilityScoreCipher;      // Data reliability (0-100)

        uint256 questionCount;
        uint256 targetResponses;
        uint256 maxResponses;
        bool allowMultipleSubmissions;
        bool requireVerification;
        bool isAnonymous;
        bool rewardsDistributed;
    }

    struct Question {
        uint256 questionId;
        uint256 surveyId;
        QuestionType qType;
        string text;

        euint32 totalAnswersCipher;         // Total answers for this question
        euint32 sumValuesCipher;            // Sum of all answer values
        euint32 avgValueCipher;             // Average answer value
        euint16 varianceCipher;             // Statistical variance
        euint16 stdDeviationCipher;         // Standard deviation
        euint8 minValueCipher;              // Minimum value
        euint8 maxValueCipher;              // Maximum value

        uint256 createdAt;
        bool isRequired;
        bool isActive;
    }

    struct Response {
        uint256 responseId;
        uint256 surveyId;
        address participant;

        euint32 qualityScoreCipher;         // Response quality (0-10000)
        euint32 consistencyScoreCipher;     // Consistency score (0-10000)
        euint16 completenessScoreCipher;    // Completeness % (0-10000)
        euint16 responseTimeCipher;         // Time taken (seconds)
        euint8 engagementLevelCipher;       // Engagement level (0-100)
        euint8 validityScoreCipher;         // Validity score (0-100)

        uint256 submittedAt;
        uint256 answersCount;
        bool isComplete;
        bool isVerified;
        bool hasReceivedReward;
    }

    struct Answer {
        uint256 answerId;
        uint256 questionId;
        uint256 responseId;
        address participant;

        euint32 valueCipher;                // Answer value (encrypted)
        euint16 confidenceCipher;           // Confidence level (0-1000)
        euint8 clarityScoreCipher;          // Clarity of answer (0-100)

        uint256 timestamp;
    }

    struct ParticipantProfile {
        address participant;
        ParticipantTier tier;

        euint32 totalSurveysCipher;         // Total surveys participated
        euint32 totalResponsesCipher;       // Total responses submitted
        euint32 reputationScoreCipher;      // Reputation score (0-10000)
        euint32 rewardsCipher;              // Total rewards earned
        euint16 completionRateCipher;       // Completion rate (0-10000)
        euint16 qualityRatingCipher;        // Quality rating (0-1000)
        euint8 reliabilityScoreCipher;      // Reliability score (0-100)
        euint8 engagementLevelCipher;       // Engagement level (0-100)

        uint256 joinedAt;
        uint256 lastActivityAt;
        bool isActive;
        bool isVerified;
    }

    struct SurveyAnalytics {
        uint256 surveyId;
        address analyst;

        euint64 totalEngagementCipher;      // Total engagement score
        euint32 responseQualityCipher;      // Average response quality
        euint32 dataReliabilityCipher;      // Data reliability score
        euint32 participationScoreCipher;   // Participation score
        euint16 completionIndexCipher;      // Completion index
        euint16 diversityScoreCipher;       // Response diversity
        euint8 biasIndicatorCipher;         // Bias indicator (0-100)
        euint8 outcomeConfidenceCipher;     // Result confidence (0-100)

        uint256 analyzedAt;
        bool isFinalized;
    }

    struct IncentivePool {
        uint256 surveyId;
        IncentiveType incentiveType;

        euint64 totalPoolCipher;            // Total reward pool
        euint64 distributedCipher;          // Distributed rewards
        euint64 remainingCipher;            // Remaining pool
        euint32 rewardPerResponseCipher;    // Reward per response
        euint16 qualityMultiplierCipher;    // Quality-based multiplier

        uint256 createdAt;
        bool isActive;
    }

    // ============ State Variables ============

    uint256 public nextSurveyId = 1;
    uint256 public nextQuestionId = 1;
    uint256 public nextResponseId = 1;
    uint256 public nextAnswerId = 1;
    uint256 public nextAnalyticsId = 1;

    mapping(uint256 => Survey) public surveys;
    mapping(uint256 => Question) public questions;
    mapping(uint256 => Response) public responses;
    mapping(uint256 => Answer) public answers;
    mapping(address => ParticipantProfile) public participants;
    mapping(uint256 => SurveyAnalytics) public analytics;
    mapping(uint256 => IncentivePool) public incentivePools;

    mapping(uint256 => uint256[]) public surveyQuestions;
    mapping(uint256 => uint256[]) public surveyResponses;
    mapping(uint256 => uint256[]) public responseAnswers;
    mapping(uint256 => mapping(address => uint256[])) public participantResponses;
    mapping(uint256 => mapping(address => bool)) public hasSubmitted;

    // Aggregate statistics (encrypted)
    euint64 public totalSurveysCountCipher;
    euint64 public totalResponsesCountCipher;
    euint32 public activeSurveysCountCipher;
    euint32 public averageQualityScoreCipher;
    euint16 public averageCompletionRateCipher;
    euint16 public averageParticipationCipher;

    // Gateway decryption mappings
    mapping(uint256 => uint256) private qualityScoreRequests;
    mapping(uint256 => uint256) private completionRateRequests;
    mapping(uint256 => uint256) private satisfactionScoreRequests;
    mapping(uint256 => uint256) private participationRateRequests;
    mapping(uint256 => uint256) private reliabilityScoreRequests;
    mapping(uint256 => uint256) private avgResponseValueRequests;
    mapping(uint256 => uint256) private outcomeConfidenceRequests;

    // ============ Role Management ============

    mapping(address => bool) public surveyAdmin;           // Can manage surveys
    mapping(address => bool) public questionDesigner;      // Can design questions
    mapping(address => bool) public dataAnalyst;           // Can analyze data
    mapping(address => bool) public incentiveManager;      // Can manage incentives
    mapping(address => bool) public verificationOfficer;   // Can verify participants

    // ============ Events ============

    event SurveyCreated(uint256 indexed surveyId, address indexed creator, SurveyCategory category, uint256 timestamp);
    event SurveyPublished(uint256 indexed surveyId, uint256 startTime, uint256 endTime);
    event SurveyStateChanged(uint256 indexed surveyId, SurveyState oldState, SurveyState newState);
    event QuestionAdded(uint256 indexed questionId, uint256 indexed surveyId, QuestionType qType);
    event ResponseSubmitted(uint256 indexed responseId, uint256 indexed surveyId, address indexed participant);
    event AnswerRecorded(uint256 indexed answerId, uint256 indexed questionId, address indexed participant);
    event SurveyAnalyzed(uint256 indexed surveyId, uint256 indexed analyticsId);
    event RewardDistributed(uint256 indexed surveyId, address indexed participant, uint256 amount);
    event ParticipantRegistered(address indexed participant, ParticipantTier tier);
    event ParticipantTierUpgraded(address indexed participant, ParticipantTier oldTier, ParticipantTier newTier);

    event QualityScoreDecrypted(uint256 indexed surveyId, uint32 score);
    event CompletionRateDecrypted(uint256 indexed surveyId, uint32 rate);
    event SatisfactionScoreDecrypted(uint256 indexed surveyId, uint8 score);
    event ParticipationRateDecrypted(uint256 indexed surveyId, uint16 rate);
    event ReliabilityScoreDecrypted(uint256 indexed surveyId, uint8 score);
    event AvgResponseValueDecrypted(uint256 indexed questionId, uint32 avg);
    event OutcomeConfidenceDecrypted(uint256 indexed surveyId, uint8 confidence);

    // ============ Errors ============

    error Unauthorized();
    error InvalidState();
    error SurveyNotFound();
    error QuestionNotFound();
    error AlreadySubmitted();
    error SurveyNotActive();
    error DeadlinePassed();
    error InsufficientResponses();
    error InvalidQuestionType();
    error RewardAlreadyDistributed();

    // ============ Modifiers ============

    modifier onlySurveyAdmin() {
        if (!surveyAdmin[msg.sender]) revert Unauthorized();
        _;
    }

    modifier onlyQuestionDesigner() {
        if (!questionDesigner[msg.sender]) revert Unauthorized();
        _;
    }

    modifier onlyDataAnalyst() {
        if (!dataAnalyst[msg.sender]) revert Unauthorized();
        _;
    }

    modifier onlyIncentiveManager() {
        if (!incentiveManager[msg.sender]) revert Unauthorized();
        _;
    }

    modifier onlyVerificationOfficer() {
        if (!verificationOfficer[msg.sender]) revert Unauthorized();
        _;
    }

    modifier onlyGateway() {
        if (msg.sender != Gateway.gatewayContractAddress()) revert Unauthorized();
        _;
    }

    // ============ Constructor ============

    constructor() {
        surveyAdmin[msg.sender] = true;
        questionDesigner[msg.sender] = true;
        dataAnalyst[msg.sender] = true;
        incentiveManager[msg.sender] = true;
        verificationOfficer[msg.sender] = true;

        // Initialize aggregate statistics
        totalSurveysCountCipher = FHE.asEuint64(0);
        totalResponsesCountCipher = FHE.asEuint64(0);
        activeSurveysCountCipher = FHE.asEuint32(0);
        averageQualityScoreCipher = FHE.asEuint32(0);
        averageCompletionRateCipher = FHE.asEuint16(0);
        averageParticipationCipher = FHE.asEuint16(0);

        FHE.allowThis(totalSurveysCountCipher);
        FHE.allowThis(totalResponsesCountCipher);
        FHE.allowThis(activeSurveysCountCipher);
        FHE.allowThis(averageQualityScoreCipher);
        FHE.allowThis(averageCompletionRateCipher);
        FHE.allowThis(averageParticipationCipher);
    }

    // ============ Role Management Functions ============

    function grantSurveyAdmin(address account) external onlySurveyAdmin {
        surveyAdmin[account] = true;
    }

    function grantQuestionDesigner(address account) external onlySurveyAdmin {
        questionDesigner[account] = true;
    }

    function grantDataAnalyst(address account) external onlySurveyAdmin {
        dataAnalyst[account] = true;
    }

    function grantIncentiveManager(address account) external onlySurveyAdmin {
        incentiveManager[account] = true;
    }

    function grantVerificationOfficer(address account) external onlySurveyAdmin {
        verificationOfficer[account] = true;
    }

    // ============ Participant Registration ============

    function registerParticipant(inEuint16 calldata reputationInput) external {
        ParticipantProfile storage profile = participants[msg.sender];
        if (profile.joinedAt != 0) revert(); // Already registered

        euint16 reputation = FHE.asEuint16(reputationInput);
        FHE.allowThis(reputation);

        profile.participant = msg.sender;
        profile.tier = ParticipantTier.Basic;
        profile.totalSurveysCipher = FHE.asEuint32(0);
        profile.totalResponsesCipher = FHE.asEuint32(0);
        profile.reputationScoreCipher = FHE.asEuint32(reputation);
        profile.rewardsCipher = FHE.asEuint32(0);
        profile.completionRateCipher = FHE.asEuint16(10000); // 100% default
        profile.qualityRatingCipher = FHE.asEuint16(500); // 50% default
        profile.reliabilityScoreCipher = FHE.asEuint8(80); // 80% default
        profile.engagementLevelCipher = FHE.asEuint8(0);
        profile.joinedAt = block.timestamp;
        profile.isActive = true;
        profile.isVerified = false;

        FHE.allowThis(profile.totalSurveysCipher);
        FHE.allowThis(profile.totalResponsesCipher);
        FHE.allowThis(profile.reputationScoreCipher);
        FHE.allowThis(profile.rewardsCipher);
        FHE.allowThis(profile.completionRateCipher);
        FHE.allowThis(profile.qualityRatingCipher);
        FHE.allowThis(profile.reliabilityScoreCipher);
        FHE.allowThis(profile.engagementLevelCipher);

        emit ParticipantRegistered(msg.sender, ParticipantTier.Basic);
    }

    // ============ Survey Creation ============

    function createSurvey(
        string calldata title,
        string calldata description,
        SurveyCategory category,
        IncentiveType incentiveType,
        uint256 duration,
        uint256 targetResponses,
        bool requireVerification
    ) external returns (uint256) {
        uint256 surveyId = nextSurveyId++;

        Survey storage survey = surveys[surveyId];
        survey.surveyId = surveyId;
        survey.creator = msg.sender;
        survey.state = SurveyState.Draft;
        survey.category = category;
        survey.incentiveType = incentiveType;
        survey.title = title;
        survey.description = description;
        survey.createdAt = block.timestamp;
        survey.deadline = block.timestamp + duration;
        survey.targetResponses = targetResponses;
        survey.maxResponses = targetResponses * 2; // Allow 2x target
        survey.requireVerification = requireVerification;
        survey.isAnonymous = true;
        survey.allowMultipleSubmissions = false;
        survey.rewardsDistributed = false;

        survey.totalResponsesCipher = FHE.asEuint32(0);
        survey.validResponsesCipher = FHE.asEuint32(0);
        survey.qualityScoreCipher = FHE.asEuint32(0);
        survey.completionRateCipher = FHE.asEuint32(0);
        survey.participationRateCipher = FHE.asEuint16(0);
        survey.avgResponseTimeCipher = FHE.asEuint16(0);
        survey.satisfactionScoreCipher = FHE.asEuint8(0);
        survey.reliabilityScoreCipher = FHE.asEuint8(0);

        FHE.allowThis(survey.totalResponsesCipher);
        FHE.allowThis(survey.validResponsesCipher);
        FHE.allowThis(survey.qualityScoreCipher);
        FHE.allowThis(survey.completionRateCipher);
        FHE.allowThis(survey.participationRateCipher);
        FHE.allowThis(survey.avgResponseTimeCipher);
        FHE.allowThis(survey.satisfactionScoreCipher);
        FHE.allowThis(survey.reliabilityScoreCipher);

        totalSurveysCountCipher = FHE.add(totalSurveysCountCipher, FHE.asEuint64(1));
        FHE.allowThis(totalSurveysCountCipher);

        emit SurveyCreated(surveyId, msg.sender, category, block.timestamp);
        return surveyId;
    }

    // ============ Question Management ============

    function addQuestion(
        uint256 surveyId,
        QuestionType qType,
        string calldata text,
        bool isRequired
    ) external onlyQuestionDesigner returns (uint256) {
        Survey storage survey = surveys[surveyId];
        if (survey.surveyId == 0) revert SurveyNotFound();
        if (survey.state != SurveyState.Draft) revert InvalidState();

        uint256 questionId = nextQuestionId++;

        Question storage question = questions[questionId];
        question.questionId = questionId;
        question.surveyId = surveyId;
        question.qType = qType;
        question.text = text;
        question.createdAt = block.timestamp;
        question.isRequired = isRequired;
        question.isActive = true;

        question.totalAnswersCipher = FHE.asEuint32(0);
        question.sumValuesCipher = FHE.asEuint32(0);
        question.avgValueCipher = FHE.asEuint32(0);
        question.varianceCipher = FHE.asEuint16(0);
        question.stdDeviationCipher = FHE.asEuint16(0);
        question.minValueCipher = FHE.asEuint8(255); // Max initial value
        question.maxValueCipher = FHE.asEuint8(0);

        FHE.allowThis(question.totalAnswersCipher);
        FHE.allowThis(question.sumValuesCipher);
        FHE.allowThis(question.avgValueCipher);
        FHE.allowThis(question.varianceCipher);
        FHE.allowThis(question.stdDeviationCipher);
        FHE.allowThis(question.minValueCipher);
        FHE.allowThis(question.maxValueCipher);

        surveyQuestions[surveyId].push(questionId);
        survey.questionCount++;

        emit QuestionAdded(questionId, surveyId, qType);
        return questionId;
    }

    // ============ Survey Publishing ============

    function publishSurvey(uint256 surveyId, uint256 startTime) external onlySurveyAdmin {
        Survey storage survey = surveys[surveyId];
        if (survey.state != SurveyState.Draft) revert InvalidState();
        if (survey.questionCount == 0) revert();

        survey.state = SurveyState.Published;
        survey.publishedAt = block.timestamp;
        survey.startTime = startTime;
        survey.endTime = survey.deadline;

        activeSurveysCountCipher = FHE.add(activeSurveysCountCipher, FHE.asEuint32(1));
        FHE.allowThis(activeSurveysCountCipher);

        emit SurveyPublished(surveyId, startTime, survey.endTime);
        emit SurveyStateChanged(surveyId, SurveyState.Draft, SurveyState.Published);
    }

    function activateSurvey(uint256 surveyId) external onlySurveyAdmin {
        Survey storage survey = surveys[surveyId];
        if (survey.state != SurveyState.Published) revert InvalidState();

        survey.state = SurveyState.Active;
        emit SurveyStateChanged(surveyId, SurveyState.Published, SurveyState.Active);
    }

    // ============ Response Submission ============

    function submitResponse(uint256 surveyId) external returns (uint256) {
        Survey storage survey = surveys[surveyId];
        if (survey.state != SurveyState.Active) revert SurveyNotActive();
        if (block.timestamp > survey.deadline) revert DeadlinePassed();
        if (!survey.allowMultipleSubmissions && hasSubmitted[surveyId][msg.sender]) {
            revert AlreadySubmitted();
        }

        ParticipantProfile storage profile = participants[msg.sender];
        if (survey.requireVerification && !profile.isVerified) revert Unauthorized();

        uint256 responseId = nextResponseId++;

        Response storage response = responses[responseId];
        response.responseId = responseId;
        response.surveyId = surveyId;
        response.participant = msg.sender;
        response.submittedAt = block.timestamp;
        response.isComplete = false;
        response.isVerified = false;
        response.hasReceivedReward = false;

        response.qualityScoreCipher = FHE.asEuint32(0);
        response.consistencyScoreCipher = FHE.asEuint32(0);
        response.completenessScoreCipher = FHE.asEuint16(0);
        response.responseTimeCipher = FHE.asEuint16(0);
        response.engagementLevelCipher = FHE.asEuint8(0);
        response.validityScoreCipher = FHE.asEuint8(100); // Default valid

        FHE.allowThis(response.qualityScoreCipher);
        FHE.allowThis(response.consistencyScoreCipher);
        FHE.allowThis(response.completenessScoreCipher);
        FHE.allowThis(response.responseTimeCipher);
        FHE.allowThis(response.engagementLevelCipher);
        FHE.allowThis(response.validityScoreCipher);

        surveyResponses[surveyId].push(responseId);
        participantResponses[surveyId][msg.sender].push(responseId);
        hasSubmitted[surveyId][msg.sender] = true;

        survey.totalResponsesCipher = FHE.add(survey.totalResponsesCipher, FHE.asEuint32(1));
        FHE.allowThis(survey.totalResponsesCipher);

        profile.totalResponsesCipher = FHE.add(profile.totalResponsesCipher, FHE.asEuint32(1));
        profile.lastActivityAt = block.timestamp;
        FHE.allowThis(profile.totalResponsesCipher);

        totalResponsesCountCipher = FHE.add(totalResponsesCountCipher, FHE.asEuint64(1));
        FHE.allowThis(totalResponsesCountCipher);

        emit ResponseSubmitted(responseId, surveyId, msg.sender);
        return responseId;
    }

    // ============ Answer Submission ============

    function submitAnswer(
        uint256 responseId,
        uint256 questionId,
        inEuint32 calldata valueInput,
        inEuint16 calldata confidenceInput
    ) external {
        Response storage response = responses[responseId];
        if (response.participant != msg.sender) revert Unauthorized();
        if (response.isComplete) revert();

        Question storage question = questions[questionId];
        if (question.surveyId != response.surveyId) revert();
        if (!question.isActive) revert();

        uint256 answerId = nextAnswerId++;

        euint32 value = FHE.asEuint32(valueInput);
        euint16 confidence = FHE.asEuint16(confidenceInput);

        FHE.allowThis(value);
        FHE.allowThis(confidence);

        Answer storage answer = answers[answerId];
        answer.answerId = answerId;
        answer.questionId = questionId;
        answer.responseId = responseId;
        answer.participant = msg.sender;
        answer.valueCipher = value;
        answer.confidenceCipher = confidence;
        answer.clarityScoreCipher = FHE.asEuint8(80); // Default 80%
        answer.timestamp = block.timestamp;

        FHE.allowThis(answer.clarityScoreCipher);

        // Update question statistics
        question.totalAnswersCipher = FHE.add(question.totalAnswersCipher, FHE.asEuint32(1));
        question.sumValuesCipher = FHE.add(question.sumValuesCipher, value);

        // Update min/max
        ebool isLessThanMin = FHE.lt(FHE.asEuint8(value), question.minValueCipher);
        question.minValueCipher = FHE.select(isLessThanMin, FHE.asEuint8(value), question.minValueCipher);

        ebool isGreaterThanMax = FHE.gt(FHE.asEuint8(value), question.maxValueCipher);
        question.maxValueCipher = FHE.select(isGreaterThanMax, FHE.asEuint8(value), question.maxValueCipher);

        FHE.allowThis(question.totalAnswersCipher);
        FHE.allowThis(question.sumValuesCipher);
        FHE.allowThis(question.minValueCipher);
        FHE.allowThis(question.maxValueCipher);

        responseAnswers[responseId].push(answerId);
        response.answersCount++;

        emit AnswerRecorded(answerId, questionId, msg.sender);
    }

    function completeResponse(uint256 responseId) external {
        Response storage response = responses[responseId];
        if (response.participant != msg.sender) revert Unauthorized();
        if (response.isComplete) revert();

        Survey storage survey = surveys[response.surveyId];

        // Check if all required questions are answered
        if (response.answersCount < survey.questionCount) revert();

        response.isComplete = true;
        response.responseTimeCipher = FHE.asEuint16(uint16(block.timestamp - response.submittedAt));
        FHE.allowThis(response.responseTimeCipher);

        // Calculate response quality (simplified)
        euint32 completeness = FHE.div(
            FHE.mul(FHE.asEuint32(response.answersCount), uint32(10000)),
            FHE.asEuint32(survey.questionCount)
        );
        response.completenessScoreCipher = FHE.asEuint16(completeness);
        FHE.allowThis(response.completenessScoreCipher);

        survey.validResponsesCipher = FHE.add(survey.validResponsesCipher, FHE.asEuint32(1));
        FHE.allowThis(survey.validResponsesCipher);

        ParticipantProfile storage profile = participants[msg.sender];
        profile.totalSurveysCipher = FHE.add(profile.totalSurveysCipher, FHE.asEuint32(1));
        FHE.allowThis(profile.totalSurveysCipher);
    }

    // ============ Survey Analysis ============

    function analyzeSurvey(uint256 surveyId) external onlyDataAnalyst {
        Survey storage survey = surveys[surveyId];
        if (survey.state != SurveyState.Active && survey.state != SurveyState.Closing) {
            revert InvalidState();
        }

        survey.state = SurveyState.Analyzing;
        emit SurveyStateChanged(surveyId, SurveyState.Active, SurveyState.Analyzing);

        uint256 analyticsId = nextAnalyticsId++;
        SurveyAnalytics storage analytic = analytics[analyticsId];

        // Calculate quality score: (validResponses / totalResponses) * 10000
        euint32 qualityScore = FHE.div(
            FHE.mul(survey.validResponsesCipher, uint32(10000)),
            survey.totalResponsesCipher
        );

        // Calculate completion rate
        euint32 completionRate = FHE.div(
            FHE.mul(survey.validResponsesCipher, uint32(10000)),
            FHE.asEuint32(uint32(survey.targetResponses))
        );

        analytic.surveyId = surveyId;
        analytic.analyst = msg.sender;
        analytic.responseQualityCipher = qualityScore;
        analytic.participationScoreCipher = FHE.asEuint32(survey.totalResponsesCipher);
        analytic.completionIndexCipher = FHE.asEuint16(completionRate);
        analytic.dataReliabilityCipher = survey.reliabilityScoreCipher;
        analytic.totalEngagementCipher = FHE.asEuint64(0); // Placeholder
        analytic.diversityScoreCipher = FHE.asEuint16(5000); // 50% default
        analytic.biasIndicatorCipher = FHE.asEuint8(30); // Low bias default
        analytic.outcomeConfidenceCipher = FHE.asEuint8(80); // 80% confidence
        analytic.analyzedAt = block.timestamp;
        analytic.isFinalized = false;

        FHE.allowThis(analytic.responseQualityCipher);
        FHE.allowThis(analytic.participationScoreCipher);
        FHE.allowThis(analytic.completionIndexCipher);
        FHE.allowThis(analytic.dataReliabilityCipher);
        FHE.allowThis(analytic.totalEngagementCipher);
        FHE.allowThis(analytic.diversityScoreCipher);
        FHE.allowThis(analytic.biasIndicatorCipher);
        FHE.allowThis(analytic.outcomeConfidenceCipher);

        survey.qualityScoreCipher = qualityScore;
        survey.completionRateCipher = completionRate;

        FHE.allowThis(survey.qualityScoreCipher);
        FHE.allowThis(survey.completionRateCipher);
        FHE.allow(qualityScore, address(this));

        // Request Gateway decryption
        uint256[] memory cts = new uint256[](1);
        cts[0] = Gateway.toUint256(qualityScore);
        uint256 requestId = Gateway.requestDecryption(
            cts,
            this.callbackQualityScore.selector,
            0,
            block.timestamp + 100,
            false
        );
        qualityScoreRequests[requestId] = surveyId;

        emit SurveyAnalyzed(surveyId, analyticsId);
    }

    function callbackQualityScore(uint256 requestId, uint32 decryptedScore) public onlyGateway {
        uint256 surveyId = qualityScoreRequests[requestId];
        Survey storage survey = surveys[surveyId];

        emit QualityScoreDecrypted(surveyId, decryptedScore);

        // Auto-transition based on quality
        if (decryptedScore >= 7500) {
            survey.state = SurveyState.Completed;

            averageQualityScoreCipher = FHE.add(averageQualityScoreCipher, survey.qualityScoreCipher);
            FHE.allowThis(averageQualityScoreCipher);

            activeSurveysCountCipher = FHE.sub(activeSurveysCountCipher, FHE.asEuint32(1));
            FHE.allowThis(activeSurveysCountCipher);

            emit SurveyStateChanged(surveyId, SurveyState.Analyzing, SurveyState.Completed);
        }
    }

    // ============ Additional Gateway Decryption Functions ============

    function requestCompletionRateDecryption(uint256 surveyId) external {
        Survey storage survey = surveys[surveyId];
        euint32 completionRate = survey.completionRateCipher;
        FHE.allow(completionRate, address(this));

        uint256[] memory cts = new uint256[](1);
        cts[0] = Gateway.toUint256(completionRate);
        uint256 requestId = Gateway.requestDecryption(
            cts,
            this.callbackCompletionRate.selector,
            0,
            block.timestamp + 100,
            false
        );
        completionRateRequests[requestId] = surveyId;
    }

    function callbackCompletionRate(uint256 requestId, uint32 decryptedRate) public onlyGateway {
        uint256 surveyId = completionRateRequests[requestId];
        emit CompletionRateDecrypted(surveyId, decryptedRate);
    }

    function requestSatisfactionScoreDecryption(uint256 surveyId) external {
        Survey storage survey = surveys[surveyId];
        euint8 satisfaction = survey.satisfactionScoreCipher;
        FHE.allow(satisfaction, address(this));

        uint256[] memory cts = new uint256[](1);
        cts[0] = Gateway.toUint256(satisfaction);
        uint256 requestId = Gateway.requestDecryption(
            cts,
            this.callbackSatisfactionScore.selector,
            0,
            block.timestamp + 100,
            false
        );
        satisfactionScoreRequests[requestId] = surveyId;
    }

    function callbackSatisfactionScore(uint256 requestId, uint8 decryptedScore) public onlyGateway {
        uint256 surveyId = satisfactionScoreRequests[requestId];
        emit SatisfactionScoreDecrypted(surveyId, decryptedScore);
    }

    function requestParticipationRateDecryption(uint256 surveyId) external {
        Survey storage survey = surveys[surveyId];
        euint16 participation = survey.participationRateCipher;
        FHE.allow(participation, address(this));

        uint256[] memory cts = new uint256[](1);
        cts[0] = Gateway.toUint256(participation);
        uint256 requestId = Gateway.requestDecryption(
            cts,
            this.callbackParticipationRate.selector,
            0,
            block.timestamp + 100,
            false
        );
        participationRateRequests[requestId] = surveyId;
    }

    function callbackParticipationRate(uint256 requestId, uint16 decryptedRate) public onlyGateway {
        uint256 surveyId = participationRateRequests[requestId];
        emit ParticipationRateDecrypted(surveyId, decryptedRate);
    }

    function requestReliabilityScoreDecryption(uint256 surveyId) external {
        Survey storage survey = surveys[surveyId];
        euint8 reliability = survey.reliabilityScoreCipher;
        FHE.allow(reliability, address(this));

        uint256[] memory cts = new uint256[](1);
        cts[0] = Gateway.toUint256(reliability);
        uint256 requestId = Gateway.requestDecryption(
            cts,
            this.callbackReliabilityScore.selector,
            0,
            block.timestamp + 100,
            false
        );
        reliabilityScoreRequests[requestId] = surveyId;
    }

    function callbackReliabilityScore(uint256 requestId, uint8 decryptedScore) public onlyGateway {
        uint256 surveyId = reliabilityScoreRequests[requestId];
        emit ReliabilityScoreDecrypted(surveyId, decryptedScore);
    }

    function requestAvgResponseValueDecryption(uint256 questionId) external {
        Question storage question = questions[questionId];

        // Calculate average: sum / count
        euint32 avg = FHE.div(question.sumValuesCipher, question.totalAnswersCipher);
        question.avgValueCipher = avg;
        FHE.allowThis(question.avgValueCipher);
        FHE.allow(avg, address(this));

        uint256[] memory cts = new uint256[](1);
        cts[0] = Gateway.toUint256(avg);
        uint256 requestId = Gateway.requestDecryption(
            cts,
            this.callbackAvgResponseValue.selector,
            0,
            block.timestamp + 100,
            false
        );
        avgResponseValueRequests[requestId] = questionId;
    }

    function callbackAvgResponseValue(uint256 requestId, uint32 decryptedAvg) public onlyGateway {
        uint256 questionId = avgResponseValueRequests[requestId];
        emit AvgResponseValueDecrypted(questionId, decryptedAvg);
    }

    function requestOutcomeConfidenceDecryption(uint256 surveyId) external {
        SurveyAnalytics storage analytic = analytics[surveyId];
        euint8 confidence = analytic.outcomeConfidenceCipher;
        FHE.allow(confidence, address(this));

        uint256[] memory cts = new uint256[](1);
        cts[0] = Gateway.toUint256(confidence);
        uint256 requestId = Gateway.requestDecryption(
            cts,
            this.callbackOutcomeConfidence.selector,
            0,
            block.timestamp + 100,
            false
        );
        outcomeConfidenceRequests[requestId] = surveyId;
    }

    function callbackOutcomeConfidence(uint256 requestId, uint8 decryptedConfidence) public onlyGateway {
        uint256 surveyId = outcomeConfidenceRequests[requestId];
        emit OutcomeConfidenceDecrypted(surveyId, decryptedConfidence);
    }

    // ============ Incentive Management ============

    function createIncentivePool(
        uint256 surveyId,
        inEuint64 calldata totalPoolInput,
        inEuint32 calldata rewardPerResponseInput
    ) external onlyIncentiveManager {
        Survey storage survey = surveys[surveyId];
        if (survey.surveyId == 0) revert SurveyNotFound();

        euint64 totalPool = FHE.asEuint64(totalPoolInput);
        euint32 rewardPerResponse = FHE.asEuint32(rewardPerResponseInput);

        FHE.allowThis(totalPool);
        FHE.allowThis(rewardPerResponse);

        IncentivePool storage pool = incentivePools[surveyId];
        pool.surveyId = surveyId;
        pool.incentiveType = survey.incentiveType;
        pool.totalPoolCipher = totalPool;
        pool.distributedCipher = FHE.asEuint64(0);
        pool.remainingCipher = totalPool;
        pool.rewardPerResponseCipher = rewardPerResponse;
        pool.qualityMultiplierCipher = FHE.asEuint16(10000); // 1x default
        pool.createdAt = block.timestamp;
        pool.isActive = true;

        FHE.allowThis(pool.distributedCipher);
        FHE.allowThis(pool.remainingCipher);
        FHE.allowThis(pool.qualityMultiplierCipher);
    }

    // ============ Participant Tier Management ============

    function upgradeParticipantTier(address participant) external onlyVerificationOfficer {
        ParticipantProfile storage profile = participants[participant];
        if (!profile.isActive) revert();

        ParticipantTier oldTier = profile.tier;
        if (oldTier == ParticipantTier.Basic) profile.tier = ParticipantTier.Regular;
        else if (oldTier == ParticipantTier.Regular) profile.tier = ParticipantTier.Active;
        else if (oldTier == ParticipantTier.Active) profile.tier = ParticipantTier.Verified;
        else if (oldTier == ParticipantTier.Verified) profile.tier = ParticipantTier.Expert;
        else if (oldTier == ParticipantTier.Expert) profile.tier = ParticipantTier.Premium;

        emit ParticipantTierUpgraded(participant, oldTier, profile.tier);
    }

    function verifyParticipant(address participant) external onlyVerificationOfficer {
        ParticipantProfile storage profile = participants[participant];
        profile.isVerified = true;
    }

    // ============ View Functions ============

    function getSurveyState(uint256 surveyId) external view returns (SurveyState) {
        return surveys[surveyId].state;
    }

    function getParticipantTier(address participant) external view returns (ParticipantTier) {
        return participants[participant].tier;
    }

    function getSurveyQuestionCount(uint256 surveyId) external view returns (uint256) {
        return surveyQuestions[surveyId].length;
    }

    function getSurveyResponseCount(uint256 surveyId) external view returns (uint256) {
        return surveyResponses[surveyId].length;
    }

    function getResponseAnswerCount(uint256 responseId) external view returns (uint256) {
        return responseAnswers[responseId].length;
    }

    function hasParticipantSubmitted(uint256 surveyId, address participant) external view returns (bool) {
        return hasSubmitted[surveyId][participant];
    }

    // ============ Manual State Transitions ============

    function transitionSurveyState(uint256 surveyId, SurveyState newState) external onlySurveyAdmin {
        Survey storage survey = surveys[surveyId];
        if (survey.surveyId == 0) revert SurveyNotFound();

        SurveyState oldState = survey.state;
        survey.state = newState;

        emit SurveyStateChanged(surveyId, oldState, newState);
    }

    function closeSurvey(uint256 surveyId) external onlySurveyAdmin {
        Survey storage survey = surveys[surveyId];
        if (survey.state != SurveyState.Active && survey.state != SurveyState.Closing) {
            revert InvalidState();
        }

        survey.state = SurveyState.Closing;
        emit SurveyStateChanged(surveyId, SurveyState.Active, SurveyState.Closing);
    }

    function finalizeSurvey(uint256 surveyId) external onlySurveyAdmin {
        Survey storage survey = surveys[surveyId];
        if (survey.state != SurveyState.Completed) revert InvalidState();

        survey.state = SurveyState.Finalized;
        emit SurveyStateChanged(surveyId, SurveyState.Completed, SurveyState.Finalized);
    }

    function cancelSurvey(uint256 surveyId) external {
        Survey storage survey = surveys[surveyId];
        if (survey.creator != msg.sender && !surveyAdmin[msg.sender]) {
            revert Unauthorized();
        }

        SurveyState oldState = survey.state;
        survey.state = SurveyState.Cancelled;

        emit SurveyStateChanged(surveyId, oldState, SurveyState.Cancelled);
    }
}
